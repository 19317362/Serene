<#@ assembly name="System.Core"
#><#@ assembly name="EnvDTE"
#><#@ assembly name="EnvDTE80" 
#><#@ assembly name="VSLangProj" 
#><#@ assembly name="$(TargetDir)Serenity.Core.dll"
#><#@ assembly name="$(TargetDir)Serenity.Web.dll" 
#><#@ assembly name="$(ProjectDir)tools\Mono.Cecil\Mono.Cecil.dll" 
#><#@ import namespace="System.Linq" 
#><#@ import namespace="System.Collections.Generic" 
#><#@ import namespace="Microsoft.VisualStudio.TextTemplating" 
#><#@ import namespace="Serenity.CodeGeneration" 
#><#
#><#+

public class SSTypeLister
{
    private List<Mono.Cecil.AssemblyDefinition> assemblyDefinitions;

    public SSTypeLister(params string[] assemblies)
    {
        if (assemblies == null)
            throw new ArgumentNullException("assemblies");

        var resolver = new Mono.Cecil.DefaultAssemblyResolver();

        foreach (var assembly in assemblies)
            resolver.AddSearchDirectory(Path.GetDirectoryName(assembly));

        assemblyDefinitions = new List<Mono.Cecil.AssemblyDefinition>();
        foreach (var assembly in assemblies)
            assemblyDefinitions.Add(Mono.Cecil.AssemblyDefinition.ReadAssembly(
                assembly, new Mono.Cecil.ReaderParameters { AssemblyResolver = resolver }));
    }
    
    private List<Mono.Cecil.TypeDefinition> GetAllBaseTypes(Mono.Cecil.TypeDefinition type)
    {
        var result = new List<Mono.Cecil.TypeDefinition>();

        while (type.BaseType != null &&
            !type.BaseType.Namespace.StartsWith("System"))
        {
            type = type.BaseType.Resolve();
            result.Add(type);
        }

        return result;
    }

    private object GetArgumentValue(object value)
    {
        if (value == null)
            return null;

        var reference = value as Mono.Cecil.TypeReference;
        if (reference != null)
            return reference.FullName;

        return value;
    }

    private ExternalAttribute ToExternalAttribute(Mono.Cecil.CustomAttribute attr)
    {
        var externalAttr = new ExternalAttribute();
        externalAttr.Type = attr.AttributeType.FullName;
        foreach (var arg in attr.ConstructorArguments)
        {
            externalAttr.Arguments.Add(new ExternalArgument
            {
                Type = arg.Type.FullName,
                Value = GetArgumentValue(arg.Value)
            });
        }

        foreach (var arg in attr.Properties)
        {
            externalAttr.Arguments.Add(new ExternalArgument
            {
                Type = arg.Argument.Type.FullName,
                Value = GetArgumentValue(arg.Argument.Value),
                Name = arg.Name
            });
        }
        
        return externalAttr;
    }

    private ExternalArgument ToExternalArgument(Mono.Cecil.ParameterDefinition prm)
    {
        var resolved = prm.Resolve();
        
        return new ExternalArgument
        {
            Name = prm.Name,
            Type = prm.ParameterType.FullName,
            IsOptional = resolved.IsOptional,
            HasDefault = resolved.HasDefault
        };
    }

    private ExternalMethod ToExternalMethod(Mono.Cecil.MethodDefinition method)
    {
        var result = new ExternalMethod();
        result.Name = method.Name;
        result.IsProtected = !method.IsPublic;
        result.IsStatic = method.IsStatic;
        result.IsConstructor = method.IsConstructor;
        result.Type = method.ReturnType.FullName;
        result.IsOverride = method.IsVirtual && method.IsReuseSlot;

        foreach (var attr in method.CustomAttributes)
            result.Attributes.Add(ToExternalAttribute(attr));
        
        foreach (var arg in method.Parameters)
            result.Arguments.Add(ToExternalArgument(arg));

        return result;
    }

    private ExternalType ToExternalType(Mono.Cecil.TypeDefinition type)
    {
        var externalType = new ExternalType
        {
            Namespace = type.Namespace,
            Name = type.Name,
            IsAbstract = type.IsAbstract,
            IsInterface = type.IsInterface,
            IsSealed = type.IsSealed,
            BaseType = type.BaseType != null ? type.BaseType.FullName : ""
        };

        foreach (var attr in type.CustomAttributes)
            externalType.Attributes.Add(ToExternalAttribute(attr));

        foreach (var intf in type.Interfaces)
            externalType.Interfaces.Add(intf.FullName);

        foreach (var method in type.Methods)
            if (!method.IsPrivate && !method.IsGetter && !method.IsSetter)
                externalType.Methods.Add(ToExternalMethod(method));

        foreach (var prm in type.GenericParameters)
            externalType.GenericParameters.Add(new ExternalGenericParameter {
                Name = prm.Name
            });

        return externalType;
    }
    
    public List<ExternalType> List()
    {
        var result = new List<ExternalType>();
        
        foreach (var assembly in this.assemblyDefinitions)
        {
            var assemblyName = assembly.Name.Name;
            foreach (var module in assembly.Modules)
            {
                foreach (var type in module.Types)
                {
                    if (!type.IsPublic)
                        continue;
                    
                    var externalType = ToExternalType(type);
                    externalType.AssemblyName = assemblyName;
                    result.Add(externalType);
                }
            }
        }
        
        return result;
    }
}

#>