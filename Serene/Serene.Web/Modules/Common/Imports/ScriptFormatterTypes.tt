<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(ProjectDir)bin\Serenity.Core.dll" #>
<#@ assembly name="$(ProjectDir)\bin\Serenity.Web.dll" #>
<#@ assembly name="$(ProjectDir)\bin\Serene.Web.dll" #>
<#@ assembly name="$(ProjectDir)\tools\Mono.Cecil\Mono.Cecil.dll" #>
<#@ assembly name="$(ProjectDir)\tools\JsEngine\MsieJavaScriptEngine.dll" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="Serenity" #>
<#@ import namespace="Serenity.Reflection" #>
<#@ import namespace="Serenity.CodeGeneration" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="MsieJavaScriptEngine" #>
<#@ include file="MultipleOutputHelper.ttinclude" #>
<#@ output extension=".log" #>
<# 
    var solutionDir = Host.ResolvePath(@"..\..\..\..\..");
    var projectDir = Host.ResolvePath(@"..\..\..");
    var scriptAssembly = (solutionDir + @"\Serene\Serene.Script\bin\debug\Serene.Script.dll");

    var lister = new ScriptTypeLister(scriptAssembly);
    var generator = new FormatterTypeGenerator();
    generator.RootNamespaces.Add("Serene");
    foreach (var type in lister.List().Values) {
        if (lister.IsFormatterType(type))
        {
            generator.FormatterTypes[type.FullName] = new FormatterTypeInfo {
                Options = lister.GetOptions(type)
            };
        }
    }

	foreach (var type in ScriptTypeLister.GetTsFormatterTypes(projectDir)) {
		generator.FormatterTypes[type.Key] = type.Value;
	}

    var code = generator.GenerateCode();
    var manager = Manager.Create(Host, GenerationEnvironment);
    manager.StartNewFile("ScriptFormatterTypes.cs");
#>
<#=code#>
<# 
    manager.EndBlock(); 
    manager.Process(true);
#>
Executed on <#=DateTime.Now.ToString("dd/MM/yyyy HH:mm:ss")#>
<#+

public class ScriptTypeLister
{
    public ScriptTypeLister(string scriptAssembly)
    {
        if (scriptAssembly == null)
            throw new ArgumentNullException("assembly");

        var resolver = new Mono.Cecil.DefaultAssemblyResolver();
        resolver.AddSearchDirectory(Path.GetDirectoryName(scriptAssembly)); 	
        this.ScriptAssembly = Mono.Cecil.AssemblyDefinition.ReadAssembly(scriptAssembly, new Mono.Cecil.ReaderParameters { AssemblyResolver = resolver });
    }
    
    private bool HasBaseType(Mono.Cecil.TypeDefinition type, string baseTypeFullName)
    {
        if (type.BaseType == null)
            return false;
            
        if (type.BaseType.Namespace.StartsWith("System"))
            return false;
            
        if (type.BaseType.FullName == baseTypeFullName)
            return true;
        else {
            return HasBaseType(type.BaseType.Resolve(), baseTypeFullName);
        }
    }

    private Mono.Cecil.TypeReference GetInterface(Mono.Cecil.TypeDefinition type, string interfaceName)
    {
        return type.Interfaces.FirstOrDefault(x => x.FullName == interfaceName);
    }
     
    private bool IsPublicProperty(Mono.Cecil.PropertyDefinition property) {
        if (property.GetMethod == null || !property.GetMethod.IsPublic ||
            property.SetMethod == null || !property.SetMethod.IsPublic)
            return false;
            
        if (property.CustomAttributes.Any(x => x.AttributeType.FullName == "System.ComponentModel.HiddenAttribute"))
            return false;
            
        if (property.PropertyType.FullName.StartsWith("System.Func"))
            return false;
            
        if (property.PropertyType.FullName.StartsWith("System.Action"))
            return false;

        if (property.PropertyType.FullName.Contains("Delegate"))
            return false;

        if (property.PropertyType.FullName.Contains("System.TypeOption"))
            return false;
    
        return true;
    }
     
    private void AddOptions(Dictionary<string, FormatterOptionInfo> result, Mono.Cecil.TypeDefinition type, bool isOptions)
    {
        foreach (var property in type.Properties) 
        {
            if (!IsPublicProperty(property))
                continue;
                          
            if (!isOptions &&
                (property.CustomAttributes.FirstOrDefault(x => 
                    x.AttributeType.FullName == "System.ComponentModel.DisplayNameAttribute" ||
                    x.AttributeType.FullName == "Serenity.OptionAttribute") == null))
                continue;
                     
            if (result.ContainsKey(property.Name))
                continue;
                              
            result[property.Name] = new FormatterOptionInfo
            {
                Name = property.Name,
                Type = property.PropertyType.FullName
            };
        }    
    }
     
    public Dictionary<string, FormatterOptionInfo> GetOptions(Mono.Cecil.TypeDefinition type)
    {
        var result = new Dictionary<string, FormatterOptionInfo>();
        
        var constructor = type.Methods.FirstOrDefault(x => x.IsConstructor && x.Parameters.Count == 2);
        if (constructor != null &&
            constructor.Parameters[0].ParameterType.FullName == "jQueryApi.jQueryObject") {
            var optionsType = constructor.Parameters[1].ParameterType;
            AddOptions(result, optionsType.Resolve(), isOptions: true);
        }
        
        var baseType = type.BaseType;
        while (baseType != null)
        {
            if (baseType.Namespace.StartsWith("System"))
                break;

            try {
                Mono.Cecil.TypeDefinition type2;
                type2 = baseType.Resolve();
                if (type2 == null)
                    break;
                    
                AddOptions(result, type2, isOptions: false);
                baseType = type2.BaseType;
            }
            catch {
                break;
            }
        }
                   
        AddOptions(result, type, isOptions: false);
        return result;
    }
    
    public Dictionary<string, Mono.Cecil.TypeDefinition> List()
    {
        var result = new Dictionary<string, Mono.Cecil.TypeDefinition>();
        
        foreach (var module in this.ScriptAssembly.Modules)
        {
            foreach (var type in module.Types)
            {
                if (type.IsAbstract)
                    continue;
                    
                if (type.HasGenericParameters)
                    continue;
                       
                result.Add(type.FullName, type);
            }
        }
        
        return result;
    }
    
    public bool IsFormatterType(Mono.Cecil.TypeDefinition type)
    {           
        return GetInterface(type, "Serenity.ISlickFormatter") != null;
    }
       
    public Mono.Cecil.AssemblyDefinition ScriptAssembly { get; private set; }

    public static MsieJsEngine SetupJsEngine(string projectDir)
    {
        var jsEngine = new MsieJsEngine();
        try
        {
            var tsServices = File.ReadAllText(projectDir + @"\tools\JsEngine\typeScriptServices.js");
            jsEngine.Evaluate(tsServices);
            using (var sr = new StreamReader(
                typeof(Serenity.CodeGeneration.DtoGenerator).Assembly.GetManifestResourceStream(
                    "Serenity.Web.Scripts.tsservices.Serenity.CodeGeneration.js")))
            {
                jsEngine.Evaluate(sr.ReadToEnd());
            }

            return jsEngine;
        }
        catch
        {
            jsEngine.Dispose();
            throw;
        }
    }

    public static Dictionary<string, FormatterTypeInfo> GetTsFormatterTypes(string projectDir) 
	{
        var files = Directory.GetFiles(projectDir + @"\Modules", "*.ts", SearchOption.AllDirectories)
			.Concat(Directory.GetFiles(projectDir + @"\Scripts", "*.ts", SearchOption.AllDirectories))
			.Where(x => !x.ToLower().EndsWith(".d.ts"))
			.Select(x => File.ReadAllText(x));

        using (var jsEngine = SetupJsEngine(projectDir))
        {
            jsEngine.SetVariableValue("sourceText", string.Join("\r\n;\r\n", files));
			var json = jsEngine.Evaluate<string>(
				"JSON.stringify(Serenity.CodeGeneration.parseFormatterTypes(sourceText))");
            return JSON.Parse<Dictionary<string, FormatterTypeInfo>>(json);
		}
	}

}
#>